# Sistema de Acciones Premium

## Descripción
El sistema de acciones premium es un mecanismo centralizado para registrar y controlar el uso de funcionalidades premium en la aplicación. Esto nos permite tener un seguimiento detallado del uso de estas características y aplicar límites según el rol del usuario y su ciclo de suscripción.

## Tipos de Acciones Premium
Actualmente se registran dos tipos de acciones premium:
1. `profile_analysis`: Análisis del perfil de LinkedIn con IA
2. `post_optimization`: Optimización de publicaciones con IA

## Estructura de Datos

### Tabla `premium_actions`
Las acciones premium se almacenan en la tabla `premium_actions` con la siguiente estructura:
- `id`: Identificador único de la acción
- `user_id`: ID del usuario que realizó la acción
- `action_type`: Tipo de acción ('profile_analysis' o 'post_optimization')
- `created_at`: Fecha y hora de la acción
- `metadata`: Datos adicionales específicos de la acción en formato JSON

### Tabla `premium_limits`
Los límites de acciones premium se gestionan dinámicamente a través de la tabla `premium_limits`:
- `id`: Identificador único del límite
- `role`: Rol del usuario ('FREE', 'PREMIUM', 'PRO')
- `action_type`: Tipo de acción
- `limit_type`: Tipo de límite ('days_between_analysis', 'max_per_post', 'monthly_limit')
- `limit_value`: Valor numérico del límite

### Tabla `user_profiles`
La tabla `user_profiles` se ha actualizado para incluir campos relacionados con la suscripción:
- `subscription_start_date`: Fecha de inicio de la suscripción actual
- `next_billing_date`: Fecha de la próxima facturación
- `role`: Rol actual del usuario
- `trial_ends_at`: Fecha de finalización del período de prueba
- `subscription_expiry`: Fecha de expiración de la suscripción

## Ciclos de Suscripción
- Los límites mensuales se calculan basándose en el ciclo de suscripción del usuario
- El ciclo comienza en la fecha de suscripción y se renueva el mismo día cada mes
- Para meses con menos días, la renovación ocurre el último día del mes
- Los límites se restablecen al inicio de cada ciclo

## Funciones Especiales

### `calculate_next_billing_date`
Calcula la próxima fecha de facturación teniendo en cuenta:
- Días del mes (28, 29, 30, 31)
- Ajuste automático para meses más cortos

### `get_current_cycle_actions`
Obtiene las acciones realizadas en el ciclo actual de suscripción:
- Filtra por fecha de inicio del ciclo
- Cuenta acciones hasta la próxima fecha de facturación

## Verificación de Límites
El sistema verifica dos tipos de límites:
1. **Límites de Tiempo:**
   - Días mínimos entre análisis de perfil
2. **Límites de Cantidad:**
   - Número máximo de acciones por ciclo de facturación
   - Número máximo de optimizaciones por post

## Gestión de Roles y Transiciones
- Los usuarios FREE tienen límites básicos
- Los usuarios PREMIUM y PRO tienen límites expandidos según su plan
- Al cambiar de rol, los límites se actualizan inmediatamente
- Al expirar una suscripción, el usuario vuelve al rol FREE

# Sistema de Roles y Permisos

## Estructura de la Base de Datos

La gestión de roles y permisos se maneja a través de dos tablas principales en Supabase:

1. `user_profiles`: Almacena la información básica del usuario y su rol
```sql
create table if not exists public.user_profiles (
  id uuid references auth.users on delete cascade not null primary key,
  role text not null default 'FREE',
  is_beta_tester boolean default false,
  trial_ends_at timestamptz default (now() + interval '15 days'),
  subscription_expiry timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  
  constraint role_check check (role in ('FREE', 'PREMIUM', 'PRO'))
);
```

2. `premium_limits`: Almacena los límites de acciones premium por rol
```sql
create table if not exists public.premium_limits (
  id bigint generated by default as identity primary key,
  role text not null,
  action_type text not null,
  limit_type text not null,
  limit_value integer not null,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint role_check check (role in ('FREE', 'PREMIUM', 'PRO', 'BETA_TESTER')),
  constraint action_type_check check (action_type in ('profile_analysis', 'post_optimization')),
  constraint limit_type_check check (limit_type in ('days_between_analysis', 'max_per_post', 'monthly_limit')),
  unique(role, action_type, limit_type)
);
```

### Tipos de Roles

1. **FREE**
   - Acceso a funcionalidades básicas
   - Sin acceso a características premium

2. **PREMIUM**
   - Acceso a todas las funcionalidades básicas
   - Acceso a características premium con límites estándar
   - Límites configurables en la tabla `premium_limits`

3. **PRO**
   - Incluye todas las características de PREMIUM
   - Límites más altos configurables en la tabla `premium_limits`

### Beta Testers
Los beta testers son usuarios que tienen acceso anticipado a nuevas funcionalidades, independientemente de su rol base:
- Cualquier usuario (FREE, PREMIUM, PRO) puede ser beta tester
- Se gestiona mediante el campo `is_beta_tester` en la tabla `user_profiles`
- Los beta testers tienen acceso a todas las funcionalidades marcadas como beta

### Implementación en el Frontend

#### Hook useUserRole

El hook `useUserRole` proporciona una interfaz para manejar los roles y permisos:

```typescript
const {
  role,                // Rol actual del usuario ('FREE', 'PREMIUM', 'PRO')
  loading,             // Estado de carga
  error,               // Error si lo hay
  isPremium,           // Función que verifica si el usuario tiene acceso premium
  isBetaTester,        // Si el usuario es beta tester
  hasAccess,           // Función para verificar acceso a funcionalidades
  canAccessBetaFeature // Función específica para verificar acceso a features beta
} = useUserRole();
```

#### Verificación de Acceso

```typescript
// Para funcionalidades premium
if (hasAccess('premium_feature_name')) {
  // Mostrar funcionalidad premium
} else {
  // Mostrar banner de actualización
}

// Para funcionalidades beta
if (canAccessBetaFeature('beta_feature_name')) {
  // Mostrar funcionalidad beta
} else {
  // Ocultar o deshabilitar la funcionalidad
}
```

### Nomenclatura de Features
- Features premium: `premium_feature_name`
- Features beta: `beta_feature_name`
- Features básicas: `feature_name`

### Verificación de Acceso Premium
El acceso premium se verifica considerando:
1. Rol del usuario (PREMIUM o PRO)
2. Estado del período de prueba
3. Estado de la suscripción

### Verificación de Acceso Beta
El acceso beta se verifica únicamente por el campo `is_beta_tester`

### Administración

#### Actualizar Rol de Usuario
```sql
update user_profiles
set role = 'PREMIUM'
where id = 'USER_ID';
```

#### Gestionar Beta Testers
```sql
-- Hacer beta tester
update user_profiles
set is_beta_tester = true
where id = 'USER_ID';

-- Quitar acceso beta
update user_profiles
set is_beta_tester = false
where id = 'USER_ID';
```

### Gestión de Límites

Los límites se gestionan a través del hook `usePremiumActions`:

```typescript
const { 
  checkProfileAnalysisLimit, 
  checkPostOptimizationLimit,
  registerAction,
  loading,
  error,
  limits
} = usePremiumActions();

// Verificar límites antes de una acción
const canPerformAnalysis = await checkProfileAnalysisLimit();
if (!canPerformAnalysis) {
  // Mostrar mensaje de límite alcanzado
}

// Registrar una acción realizada
await registerAction('profile_analysis', {
  analysis_id: '123',
  timestamp: new Date().toISOString()
});
```

### Administración de Límites

Para modificar los límites de acciones premium:

```sql
-- Actualizar un límite específico
update premium_limits
set limit_value = 50
where role = 'PRO' 
  and action_type = 'post_optimization'
  and limit_type = 'monthly_limit';

-- Consultar límites actuales
select * from premium_limits
where role = 'PREMIUM'
order by action_type, limit_type;
```

### Consideraciones de Seguridad

1. **RLS (Row Level Security)**
   - Implementado en todas las tablas relevantes
   - Los usuarios solo pueden ver y modificar sus propios datos
   - Los límites son de solo lectura para los usuarios

2. **Verificación en Múltiples Capas**
   - Frontend: A través de los hooks `useUserRole` y `usePremiumActions`
   - Backend: Mediante políticas RLS y funciones RPC
   - Base de datos: Constraints y checks en las tablas

3. **Auditoría**
   - Todas las acciones premium se registran en la tabla `premium_actions`
   - Cada registro incluye metadata para análisis detallado
   - Timestamps automáticos para seguimiento temporal 

# Componentes de UI

## Sidebar

### Estructura
El Sidebar es un componente colapsable que proporciona navegación y muestra información del usuario:
- Logo y nombre de la aplicación
- Menú de navegación
- Estadísticas de uso del plan
- Botón de cerrar sesión

### UsageStats
El componente UsageStats muestra información sobre el uso de funcionalidades premium:

1. **Visualización Colapsada**
   - Muestra solo el icono del plan actual:
     - 🚀 (Rocket) para plan PRO
     - 👑 (Crown) para plan PREMIUM
     - 👤 (User) para plan FREE

2. **Visualización Expandida**
   - Muestra las barras de progreso de uso
   - Indica los límites numéricos (usado/total)
   - Muestra el nombre del plan debajo del icono

3. **Barras de Progreso**
   - Análisis de Perfil: Muestra el uso actual vs límite
   - Optimizaciones: Muestra el uso mensual vs límite
   - Gradiente azul a índigo para indicar el progreso

4. **Actualización Automática**
   - Los datos se cargan al montar el componente
   - Se actualizan cuando cambia el rol del usuario
   - Consulta los límites específicos del rol desde la base de datos

### Ejemplo de Uso
```tsx
// En el Sidebar
<div className="flex flex-col h-full">
  {/* ... navegación ... */}
  <UsageStats />
  {/* ... botón de cerrar sesión ... */}
</div>
```

### Consideraciones de Diseño
1. **Responsividad**
   - El componente se adapta al estado colapsado/expandido del Sidebar
   - Las transiciones son suaves para mejorar la UX
   - Los textos usan `whitespace-nowrap` para evitar saltos de línea

2. **Accesibilidad**
   - Los iconos tienen colores distintivos para cada plan
   - Los números son claramente legibles
   - Las barras de progreso tienen suficiente contraste

3. **Estado de Carga**
   - Los valores se inicializan en 0
   - Se muestran los datos reales una vez cargados
   - Manejo de errores silencioso para no interrumpir la UX

# Gestión de Posts

## Estados de Post

Los estados de post se manejan mediante un tipo ENUM en la base de datos:

```sql
CREATE TYPE post_state AS ENUM (
  'borrador',
  'listo',
  'planificado',
  'eliminado'
);
```

Los posts pueden tener los siguientes estados:

1. **borrador**
   - Post en proceso de edición
   - No visible en el calendario
   - Puede ser modificado libremente

2. **listo**
   - Post finalizado pero pendiente de publicar
   - Visible en la lista pero no en el calendario
   - Puede ser publicado manualmente

3. **planificado**
   - Post programado para una fecha específica
   - Visible tanto en la lista como en el calendario
   - La fecha de publicación puede ser modificada

4. **eliminado**
   - Post marcado como eliminado (soft delete)
   - No visible en ninguna vista
   - Mantiene sus relaciones con otras tablas (optimizaciones, etc)
   - No puede ser modificado ni recuperado

### Modificación del ENUM
Para añadir nuevos estados, se debe modificar el tipo ENUM:
```sql
-- Añadir nuevo valor al enum
ALTER TYPE post_state ADD VALUE IF NOT EXISTS 'nuevo_estado';
```

Nota: Los valores ENUM solo se pueden añadir, no modificar ni eliminar una vez creados.

## Implementación del Soft Delete

Para preservar la integridad referencial y el historial de optimizaciones, los posts no se eliminan físicamente de la base de datos. En su lugar:

1. Se marcan como 'eliminado' mediante el estado ENUM
2. Se filtran automáticamente en todas las consultas
3. Mantienen sus relaciones con otras tablas (post_optimizations, etc)

### Ejemplo de Implementación

```typescript
// Al cargar posts
const loadPosts = async () => {
  const { data, error } = await supabase
    .from('posts')
    .select('*')
    .neq('state', 'eliminado')
    .order('created_at', { ascending: false });
};

// Al "eliminar" un post
const deletePost = async (postId: string) => {
  const { error } = await supabase
    .from('posts')
    .update({ state: 'eliminado' })
    .eq('id', postId);
};
```

### Consideraciones

1. **Filtrado Automático**
   - Todas las consultas deben incluir el filtro `state != 'eliminado'`
   - Esto aplica tanto para la lista como para el calendario

2. **Integridad de Datos**
   - Los posts eliminados mantienen sus optimizaciones y metadatos
   - Esto permite mantener estadísticas e históricos precisos

3. **Rendimiento**
   - El soft delete no impacta significativamente el rendimiento
   - Los índices en la columna `state` optimizan las consultas

# Guía del Proyecto

## Estructura del Proyecto

### Frontend (Next.js + Vite)
- `src/components/` - Componentes React
  - `Pricing.tsx` - Página de planes y precios
  - `SuccessPage.tsx` - Página post-compra
- `src/lib/` - Utilidades y configuración
  - `stripe.ts` - Cliente de Stripe y funciones relacionadas
  - `supabase.ts` - Cliente de Supabase

### Backend (Supabase)
- Tablas principales:
  - `user_profiles` - Perfiles de usuario y suscripciones
  - `posts` - Posts de LinkedIn
  - `stripe_customers` - Clientes de Stripe
  - `stripe_subscriptions` - Suscripciones activas

- Edge Functions:
  - `create-checkout-session` - Crear sesión de pago
  - `create-portal-session` - Portal de cliente Stripe
  - `stripe-webhook` - Webhook para eventos de Stripe

## Flujo de Suscripción

1. Usuario accede a `/pricing`
2. Selecciona un plan (PREMIUM o PRO)
3. Se crea sesión de checkout en Stripe
4. Usuario completa el pago
5. Webhook actualiza:
   - `stripe_customers`
   - `stripe_subscriptions`
   - `user_profiles` (role, fechas, estado)

## Gestión de Suscripciones

### Roles de Usuario
- FREE: Acceso básico
- PREMIUM: Funcionalidades premium
- PRO: Todas las funcionalidades

### Estados de Suscripción
- free: Sin suscripción activa
- active: Suscripción vigente
- canceled: Cancelada
- trialing: En período de prueba

### Funciones de Gestión Manual
```sql
-- Hacer PREMIUM
SELECT set_user_premium('uuid-del-usuario');

-- Hacer PRO
SELECT set_user_pro('uuid-del-usuario');

-- Hacer FREE
SELECT set_user_free('uuid-del-usuario');
```

## Variables de Entorno

### Desarrollo (.env.development)
```env
VITE_STRIPE_PUBLISHABLE_KEY=pk_test_...
```

### Producción (.env.production)
```env
VITE_STRIPE_PUBLISHABLE_KEY=pk_live_...
```

### Supabase Edge Functions
```env
STRIPE_SECRET_KEY=sk_test/live_...
STRIPE_WEBHOOK_SECRET=whsec_...
```

## Pruebas

### Tarjetas de Prueba
- Éxito: 4242 4242 4242 4242
- Cualquier fecha futura
- Cualquier CVC
- Cualquier código postal

### Verificación
1. Comprobar creación en `stripe_customers`
2. Verificar suscripción en `stripe_subscriptions`
3. Confirmar actualización en `user_profiles`

## Mantenimiento

### Monitorización
- Dashboard de Stripe
- Logs de Supabase Functions
- Estado de suscripciones

### Backups
- Respaldo de IDs de productos/precios
- Configuración documentada
- Variables de entorno seguras

